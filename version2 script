#!/bin/bash

# Chef Node Monitoring and Auto-Remediation Script
# This script runs knife status, identifies nodes that haven't checked in for 3+ hours,
# logs into those servers, runs chef-client, and creates detailed logs

# Configuration
LOG_DIR="/var/log/chef-monitoring"
LOG_FILE="$LOG_DIR/chef-monitoring-$(date +%Y-%m-%d).log"
ERROR_LOG="$LOG_DIR/chef-errors-$(date +%Y-%m-%d).log"
SUMMARY_LOG="$LOG_DIR/chef-summary-$(date +%Y-%m-%d).log"
SSH_USER="${CHEF_SSH_USER:-chef-admin}"  # Set via environment variable or default
SSH_KEY="${CHEF_SSH_KEY:-~/.ssh/chef-monitoring-key}"  # SSH key path
MAX_HOURS=3
CHEF_CLIENT_TIMEOUT=300  # 5 minutes timeout for chef-client run

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Create log directory if it doesn't exist
mkdir -p "$LOG_DIR"

# Function to log messages
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    case $level in
        "ERROR")
            echo "[$timestamp] [$level] $message" >> "$ERROR_LOG"
            echo -e "${RED}[$level]${NC} $message"
            ;;
        "SUCCESS")
            echo -e "${GREEN}[$level]${NC} $message"
            ;;
        "WARNING")
            echo -e "${YELLOW}[$level]${NC} $message"
            ;;
        "INFO")
            echo -e "${BLUE}[$level]${NC} $message"
            ;;
        *)
            echo "[$level] $message"
            ;;
    esac
}

# Function to send notification (customize as needed)
send_notification() {
    local subject=$1
    local body=$2
    
    # Example: Send email notification (uncomment and configure as needed)
    # echo "$body" | mail -s "$subject" admin@yourcompany.com
    
    # Example: Send Slack notification (uncomment and configure webhook)
    # curl -X POST -H 'Content-type: application/json' \
    #     --data "{\"text\":\"$subject\\n$body\"}" \
    #     YOUR_SLACK_WEBHOOK_URL
    
    log_message "INFO" "Notification sent: $subject"
}

# Function to check if a server is reachable
check_server_connectivity() {
    local server=$1
    
    # Test SSH connectivity
    timeout 10 ssh -o ConnectTimeout=5 -o BatchMode=yes -i "$SSH_KEY" "$SSH_USER@$server" "echo 'Connection test'" &>/dev/null
    return $?
}

# Function to run chef-client on a remote server
run_chef_client() {
    local server=$1
    local server_log="$LOG_DIR/chef-client-${server}-$(date +%Y-%m-%d-%H%M%S).log"
    
    log_message "INFO" "Running chef-client on $server"
    
    # Check connectivity first
    if ! check_server_connectivity "$server"; then
        log_message "ERROR" "Cannot connect to $server via SSH"
        return 1
    fi
    
    # Run chef-client with timeout
    timeout "$CHEF_CLIENT_TIMEOUT" ssh -i "$SSH_KEY" "$SSH_USER@$server" "
        sudo chef-client -l info 2>&1 | tee /tmp/chef-client-run.log
        echo 'CHEF_CLIENT_EXIT_CODE='$?
    " > "$server_log" 2>&1
    
    local ssh_exit_code=$?
    
    # Extract chef-client exit code from output
    local chef_exit_code=$(grep "CHEF_CLIENT_EXIT_CODE=" "$server_log" | cut -d'=' -f2)
    
    if [ "$ssh_exit_code" -eq 124 ]; then
        log_message "ERROR" "chef-client timed out on $server after ${CHEF_CLIENT_TIMEOUT} seconds"
        return 1
    elif [ "$ssh_exit_code" -ne 0 ]; then
        log_message "ERROR" "SSH connection failed to $server (exit code: $ssh_exit_code)"
        return 1
    elif [ "$chef_exit_code" -ne 0 ]; then
        log_message "WARNING" "chef-client completed with non-zero exit code ($chef_exit_code) on $server"
        return 2
    else
        log_message "SUCCESS" "chef-client completed successfully on $server"
        return 0
    fi
}

# Function to parse knife status output and identify stale nodes
get_stale_nodes() {
    local stale_nodes=()
    local current_time=$(date +%s)
    
    # Run knife status and parse output
    knife status 2>/dev/null | while read line; do
        if [[ $line =~ ^([0-9]+)\ hours,\ ([^,]+),\ (.+)$ ]]; then
            local hours=${BASH_REMATCH[1]}
            local node=${BASH_REMATCH[2]}
            local fqdn=${BASH_REMATCH[3]}
            
            if [ "$hours" -gt "$MAX_HOURS" ]; then
                echo "$node:$fqdn:${hours}h"
            fi
        elif [[ $line =~ ^([0-9]+)\ hours\ ([0-9]+)\ minutes,\ ([^,]+),\ (.+)$ ]]; then
            local hours=${BASH_REMATCH[1]}
            local node=${BASH_REMATCH[3]}
            local fqdn=${BASH_REMATCH[4]}
            
            if [ "$hours" -gt "$MAX_HOURS" ]; then
                echo "$node:$fqdn:${hours}h"
            fi
        fi
    done
}

# Function to generate summary report
generate_summary() {
    local processed_nodes=$1
    local successful_runs=$2
    local failed_runs=$3
    local warning_runs=$4
    
    local summary_content="
=== Chef Monitoring Summary - $(date '+%Y-%m-%d %H:%M:%S') ===

Configuration:
- Maximum allowed hours since last check-in: $MAX_HOURS
- SSH User: $SSH_USER
- SSH Key: $SSH_KEY
- Timeout for chef-client: ${CHEF_CLIENT_TIMEOUT}s

Results:
- Total nodes processed: $processed_nodes
- Successful chef-client runs: $successful_runs
- Failed runs: $failed_runs
- Runs with warnings: $warning_runs

Log files:
- Main log: $LOG_FILE
- Error log: $ERROR_LOG
- Individual server logs: $LOG_DIR/chef-client-*

=== End Summary ===
"
    
    echo "$summary_content" >> "$SUMMARY_LOG"
    log_message "INFO" "Summary report generated: $SUMMARY_LOG"
}

# Main execution function
main() {
    log_message "INFO" "Starting Chef monitoring script"
    
    # Check if knife command is available
    if ! command -v knife &> /dev/null; then
        log_message "ERROR" "knife command not found. Please ensure Chef Workstation is installed and configured."
        exit 1
    fi
    
    # Check if SSH key exists
    if [ ! -f "$SSH_KEY" ]; then
        log_message "ERROR" "SSH key not found: $SSH_KEY"
        exit 1
    fi
    
    # Initialize counters
    local processed_nodes=0
    local successful_runs=0
    local failed_runs=0
    local warning_runs=0
    
    log_message "INFO" "Checking knife status for nodes not checked in for more than $MAX_HOURS hours"
    
    # Get list of stale nodes
    local stale_nodes=$(get_stale_nodes)
    
    if [ -z "$stale_nodes" ]; then
        log_message "INFO" "No nodes found that haven't checked in for more than $MAX_HOURS hours"
        generate_summary 0 0 0 0
        exit 0
    fi
    
    log_message "INFO" "Found stale nodes, processing..."
    
    # Process each stale node
    while IFS= read -r node_info; do
        if [ -n "$node_info" ]; then
            IFS=':' read -r node_name fqdn hours <<< "$node_info"
            
            log_message "WARNING" "Node $node_name ($fqdn) hasn't checked in for $hours"
            
            ((processed_nodes++))
            
            # Attempt to run chef-client on the node
            run_chef_client "$fqdn"
            local result=$?
            
            case $result in
                0)
                    ((successful_runs++))
                    ;;
                1)
                    ((failed_runs++))
                    ;;
                2)
                    ((warning_runs++))
                    ;;
            esac
            
            # Small delay between nodes to avoid overwhelming the network
            sleep 2
        fi
    done <<< "$stale_nodes"
    
    # Generate summary
    generate_summary "$processed_nodes" "$successful_runs" "$failed_runs" "$warning_runs"
    
    # Send notification if there were issues
    if [ $failed_runs -gt 0 ] || [ $warning_runs -gt 0 ]; then
        local notification_subject="Chef Monitoring Alert - $(date '+%Y-%m-%d')"
        local notification_body="Chef monitoring completed with issues:
        
Processed: $processed_nodes nodes
Successful: $successful_runs
Failed: $failed_runs  
Warnings: $warning_runs

Check logs at: $LOG_DIR"
        
        send_notification "$notification_subject" "$notification_body"
    fi
    
    log_message "INFO" "Chef monitoring script completed"
    
    # Clean up old log files (keep last 30 days)
    find "$LOG_DIR" -name "*.log" -type f -mtime +30 -delete 2>/dev/null
}

# Handle script interruption
trap 'log_message "WARNING" "Script interrupted"; exit 1' INT TERM

# Run main function
main "$@"
